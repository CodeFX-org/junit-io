:page-title: Disable Parameterized Test Based on Parameter Values
:page-description: Extends JUnit Jupiter with `@DisableIfParameter`, which selectively disables parameterized tests

The `@DisableIfParameter` annotation can be used to selectively disable parameterized tests based on their parameter values (converted with `toString()`).
The annotation is only supported on test method level for parameterized tests.
Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation , `@DisableIfParameter` is validated before each execution of a parameterized test.
As a consequence, instead of disabling the entire set of parameterized tests, each test is evaluated and possibly disabled individually.

[source,java]
----
// disable invocations whose parameter contains "she"
@DisableIfParameter(contains = "she")
@ParameterizedTest
@ValueSource(strings = {
        "Tread lightly, she is near",
        "Under the snow,",
        "Speak gently, she can hear",
        "The daisies grow."
})
void interceptContains(String line) {
}
----

The test `interceptContains` ordinarily would run four times, but because the first and third lines contain the word "she", those invocations get disabled.

You can specify more than one substring at a time:

[source,java]
----
@DisableIfParameter(contains = { "bright", "dust" })
@ParameterizedTest
@CsvSource(delimiter = ';', value = {
        "All her bright golden hair;Tarnished with rust,",
        "She that was young and fair;Fallen to dust."
})
void interceptContainsAny(String line, String line2) {
}
----

These test invocations get disabled:

* The first invocation, because it has a parameter containing "bright".
* The second invocation, because it has a parameter containing "dust".

`DisableIfParameter` will disable the test invocation if any parameter value matches any value from `contains`.
In this case, the test `interceptContainsAny` should have run two times, but both invocations got disabled.

If substrings are not powerful enough, you can also use regular expressions, with the `matches` value:

[source,java]
----
// disable invocations whose parameter ends with 'knew' or 'grew'
@DisableIfParameter(matches = { ".*knew", ".*grew" })
@ParameterizedTest
@ValueSource(strings = {
        "Lily-like, white as snow,",
        "She hardly knew",
        "She was a woman, so",
        "Sweetly she grew"
})
void interceptMatches(String value) {
}
----

These test invocations get disabled:

* The second invocation, because it has a parameter that matches ".*knew" - ends with knew.
* The fourth invocation, because it has a parameter that matches ".*grew" - ends with grew.

Just like with `contains`, if any parameter value matches any expression from `matches`, the invocation gets disabled.

You can combine these options.
In this case a test is disabled if any parameter value contains a substring _or_ matches an expression:

[source,java]
----
@ParameterizedTest
@DisableIfParameter(
        contains = { "sonnet", "life" },
        matches = "^.*(Peace, )\\1.*$")
@ValueSource(strings = {
        "Peace, Peace, she cannot hear",
        "Lyre or sonnet,",
        "All my lifeâ€™s buried here,",
        "Heap earth upon it."
})
void interceptBoth(String value) {
}
----

These test invocations get disabled:

* The first invocation, because it matches the regular expression - contains "Peace, " twice.
* The second invocation, because it has a parameter that contains "sonnet".
* The third invocation, because it has a parameter that contains "life".